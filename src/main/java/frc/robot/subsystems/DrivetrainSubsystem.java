// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import com.kauailabs.navx.frc.AHRS;
import frc.robot.commands.*;
import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import edu.wpi.first.wpilibj.SPI;
import com.ctre.phoenix.motorcontrol.NeutralMode;

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.motorcontrol.MotorControllerGroup;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class DrivetrainSubsystem extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private WPI_TalonFX frontLeftTalon;
private WPI_TalonFX backLeftTalon;
private MotorControllerGroup leftController;
private WPI_TalonFX frontRightTalon;
private WPI_TalonFX backRightTalon;
private MotorControllerGroup rightController;
private DifferentialDrive differentialDrive;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public AHRS ahrs;
    /**
    *
    */
    public DrivetrainSubsystem() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
frontLeftTalon = new WPI_TalonFX(2);
 
 

backLeftTalon = new WPI_TalonFX(3);
 
 

leftController = new MotorControllerGroup(frontLeftTalon, backLeftTalon  );
 addChild("LeftController",leftController);
 

frontRightTalon = new WPI_TalonFX(1);
 
 

backRightTalon = new WPI_TalonFX(0);
 
 

rightController = new MotorControllerGroup(frontRightTalon, backRightTalon  );
 addChild("RightController",rightController);
 

differentialDrive = new DifferentialDrive(leftController, rightController);
 addChild("DifferentialDrive",differentialDrive);
 differentialDrive.setSafetyEnabled(true);
differentialDrive.setExpiration(0.1);
differentialDrive.setMaxOutput(1.0);



    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

    ahrs = new AHRS(SPI.Port.kMXP);
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void ArcadeDrive(double xSpeed, double zRotation) {
        if(! forward)
            zRotation = -zRotation;
        xSpeed = xSpeed * .7;
        differentialDrive.arcadeDrive(xSpeed, zRotation, true);
       // System.out.println("real speed: " + frontLeftTalon.get() + "  "+ frontRightTalon.get() + "  "+ backLeftTalon.get() + "  "+ backRightTalon.get() + " - ");
       // System.out.println("values: " + xSpeed + "  " + zRotation);
    }
    public void rotate(boolean clockwise) {
        double speed = .4;
        if (clockwise)
            speed = -.4;
        differentialDrive.tankDrive(speed, speed);
        
    }
    public double leftPosition() {
        return frontLeftTalon.getSelectedSensorPosition();
    }

    public void setspeed(double speed) {
        differentialDrive.arcadeDrive(0,speed,  true);
    }

    public void brakeMode() {
        frontRightTalon.setNeutralMode(NeutralMode.Brake);
        frontLeftTalon.setNeutralMode(NeutralMode.Brake);
    }

    public void coastMode() {
        frontRightTalon.setNeutralMode(NeutralMode.Coast);
        frontLeftTalon.setNeutralMode(NeutralMode.Coast);
    }

    public void reset() {
        frontRightTalon.setSelectedSensorPosition(0);
        frontLeftTalon.setSelectedSensorPosition(0);
    }

    private boolean forward = true;
    public void flip() {
        forward = ! forward;
    }
}

